#!/usr/bin/env python3
import os
import sys
import argparse
import fields2cover as f2c
import pymap3d as pm
import json

from romea_path_tools.path_planning_utils import discretize_swaths
from romea_path_tools.path import Path


def parse_args():
    parser = argparse.ArgumentParser(
        prog=os.path.basename(sys.argv[0]),
        description="Generate a path from a CSV file containing swaths",
    )
    parser.add_argument("input_path", type=str, help="input CSV or geojson file containing the swaths")
    parser.add_argument("path", type=str, help="output path file")
    return parser.parse_args()


class PathGenerator:
    def __init__(self, robot_width, operation_width, min_radius):
        self.swaths = None
        self.path = None
        self.polygon = None

        self.robot = f2c.Robot(robot_width, operation_width)
        self.robot.setMinTurningRadius(min_radius)
        self.robot.setCruiseVel(1.0)
        self.robot.setMaxDiffCurv(0.4)  # 1/mÂ²
        self.step_size = 0.1  # m

    def create_swaths_from_csv(self, filename):
        points = []
        with open(filename, "r") as file:
            file.readline()
            for line in file.readlines():
                values = tuple(map(float, line.split(",")))
                points.append(values)

        self.swaths = f2c.Swaths()
        for a, b in zip(points[::2], points[1::2]):
            line_string = f2c.LineString(
                f2c.Point(*a),
                f2c.Point(*b),
            )
            swath = f2c.Swath(line_string)
            self.swaths.emplace_back(swath)

        self.origin = (0, 0, 0)

    def create_swaths_from_geojson(self, filename):
        with open(filename, "r") as file:
            data = json.load(file)

        is_first_point = True

        points = []
        for feature in data["features"]:
            if feature["geometry"]["type"] == "LineString":
                coords = feature["geometry"]["coordinates"]
                for lon, lat in coords:
                    if is_first_point:
                        self.origin = lon, lat, 0
                        is_first_point = False

                    x, y, _ = pm.geodetic2enu(lat, lon, 0, self.origin[1], self.origin[0], 0)
                    points.append((x, y))

        self.swaths = f2c.Swaths()
        for a, b in zip(points[::2], points[1::2]):
            line_string = f2c.LineString(
                f2c.Point(*a),
                f2c.Point(*b),
            )
            swath = f2c.Swath(line_string)
            self.swaths.emplace_back(swath)

    def path_planning(self):
        path_planner = f2c.PP_PathPlanning()

        # turning = f2c.PP_DubinsCurves()
        turning = f2c.PP_DubinsCurvesCC()
        # turning = f2c.PP_ReedsSheppCurves()
        # turning = f2c.PP_ReedsSheppCurvesHC()

        turning.discretization = self.step_size
        self.path = path_planner.planPath(self.robot, self.swaths, turning)

        # fix: Add missing last point manually
        last_state = f2c.PathState()
        last_state.point = self.swaths.back().endPoint()
        self.path.addState(last_state)

        self.path = discretize_swaths(self.path, self.step_size + 0.01)

    def export_path(self, filename):
        tiara_path = Path()
        tiara_path.columns = ["x", "y", "speed"]

        tiara_path.anchor = [self.origin[1], self.origin[0], self.origin[2]]

        TURN = f2c.PathSectionType_TURN
        SWATH = f2c.PathSectionType_SWATH
        previous_dir = None
        previous_type = TURN

        for i, state in enumerate(self.path.getStates()):
            if previous_dir != state.dir:
                tiara_path.append_section([])

            if previous_type == SWATH and state.type == TURN:
                if i > 0:
                    tiara_path.append_annotation("zone_exit", "work", i - 1)
                tiara_path.append_annotation("zone_enter", "uturn", i)

            if previous_type == TURN and state.type == SWATH:
                if i > 0:
                    tiara_path.append_annotation("zone_exit", "uturn", i - 1)
                tiara_path.append_annotation("zone_enter", "work", i)

            state.velocity *= state.dir
            tiara_path.append_point((state.point.getX(), state.point.getY(), state.velocity))

            previous_dir = state.dir
            previous_type = state.type

        tiara_path.append_annotation("zone_exit", "work", len(self.path.getStates()) - 1)

        tiara_path.save(filename)


def main():
    args = parse_args()
    operation_width = 1.58
    # min_radius = 3.5
    min_radius = 3.2
    robot_width = 1.0

    if operation_width < robot_width:
        robot_width = operation_width

    pg = PathGenerator(robot_width, operation_width, min_radius)

    if args.input_path.endswith('.csv'):
        pg.create_swaths_from_csv(args.input_path)
    elif args.input_path.endswith('.geojson'):
        pg.create_swaths_from_geojson(args.input_path)
    else:
        raise ValueError("Unsupported file format. Please use .csv or .geojson files.")

    pg.path_planning()

    print(f"nb swaths: {pg.swaths.size()}")
    print(f"nb generated points: {pg.path.size()}")
    print(f"WGS84 origin: {pg.origin}")
    pg.export_path(args.path)


if __name__ == "__main__":
    main()
