#!/usr/bin/env python3
import os
import sys
import argparse
import fields2cover as f2c

from romea_path_tools.path_planning_utils import discretize_swaths
from romea_path_tools.path import Path


def parse_args():
    parser = argparse.ArgumentParser(
        prog=os.path.basename(sys.argv[0]),
        description="Generate a path from a CSV file containing swaths",
    )
    parser.add_argument('csv', type=str, help='input CSV file containing the swaths')
    parser.add_argument('path', type=str, help='output path file')
    return parser.parse_args()


class PathGenerator:
    def __init__(self, robot_width, operation_width, min_radius):
        self.swaths = None
        self.path = None
        self.polygon = None

        self.robot = f2c.Robot(robot_width, operation_width)
        self.robot.setMinTurningRadius(min_radius)
        self.robot.setCruiseVel(1.0)
        self.robot.setMaxDiffCurv(0.4)  # 1/mÂ²
        self.step_size = 0.1  # m

    def create_swaths_from_csv(self, filename):
        points = []
        with open(filename, "r") as file:
            file.readline()
            for line in file.readlines():
                values = tuple(map(float, line.split(",")))
                points.append(values)

        self.swaths = f2c.Swaths()
        for a, b in zip(points[::2], points[1::2]):
            line_string = f2c.LineString(
                f2c.Point(*a),
                f2c.Point(*b),
            )
            swath = f2c.Swath(line_string)
            self.swaths.emplace_back(swath)

    def path_planning(self):
        path_planner = f2c.PP_PathPlanning()

        # turning = f2c.PP_DubinsCurves()
        turning = f2c.PP_DubinsCurvesCC()
        # turning = f2c.PP_ReedsSheppCurves()
        # turning = f2c.PP_ReedsSheppCurvesHC()

        turning.discretization = self.step_size
        self.path = path_planner.planPath(self.robot, self.swaths, turning)

        # fix: Add missing last point manually
        # last_state = f2c.PathState()
        # last_state.point = self.swaths.back().endPoint()
        # self.path.addState(last_state)

        self.path = discretize_swaths(self.path, self.step_size + .01)

    def export_path(self, filename):
        tiara_path = Path()
        tiara_path.columns = ["x", "y", "speed"]

        origin = (46.339159, 3.433923, 279.18)
        tiara_path.anchor = [origin[1], origin[0], origin[2]]

        TURN = f2c.PathSectionType_TURN
        SWATH = f2c.PathSectionType_SWATH
        previous_dir = None
        previous_type = TURN

        for i, state in enumerate(self.path.getStates()):
            if previous_dir != state.dir:
                tiara_path.append_section([])

            if previous_type == SWATH and state.type == TURN:
                if i > 0:
                    tiara_path.append_annotation("zone_exit", "work", i - 1)
                tiara_path.append_annotation("zone_enter", "uturn", i)

            if previous_type == TURN and state.type == SWATH:
                if i > 0:
                    tiara_path.append_annotation("zone_exit", "uturn", i - 1)
                tiara_path.append_annotation("zone_enter", "work", i)

            state.velocity *= state.dir
            tiara_path.append_point((state.point.getX(), state.point.getY(), state.velocity))

            previous_dir = state.dir
            previous_type = state.type

        tiara_path.append_annotation("zone_exit", "work", len(self.path.getStates()) - 1)

        tiara_path.save(filename)


def main():
    args = parse_args()
    operation_width = 1.58
    min_radius = 2.5
    # min_radius = 3.68
    robot_width = 1.0

    if operation_width < robot_width:
        robot_width = operation_width

    pg = PathGenerator(robot_width, operation_width, min_radius)
    pg.create_swaths_from_csv(args.csv)
    pg.path_planning()
    pg.export_path(args.path)


if __name__ == "__main__":
    main()
