#!/usr/bin/env python3
import argparse
import os
import sys
from romea_path_tools.path import Path


def parse_args():
    parser = argparse.ArgumentParser(
        prog=os.path.basename(sys.argv[0]),
        description="Merge multiple trajectory files. \
                End of trajectory n will be attached to start of trajectory n+1",
    )
    parser.add_argument("traj_file_1", type=str, help="first trajectory")
    parser.add_argument("traj_file_n", nargs="+", type=str, help="trajectories to merge")
    parser.add_argument(
        "-o", "--output", type=str, required=True, help="path of the output trajectory"
    )
    return parser.parse_args()


def merge_two_paths(path1: Path, path2: Path):
    if path1.anchor != path2.anchor:
        raise RuntimeError(f"{path1.name} and {path2.name} have different anchors.")
    if path1.columns != path2.columns:
        raise RuntimeError(f"{path1.name} and {path2.name} have different columns.")

    p1 = path1.positions()[-1]
    p2 = path2.positions()[0]
    if (p2[0] - p1[0]) ** 2 + (p2[1] - p2[1]) ** 2 > 0.01:
        print(
            f"Warning : distance between end of {path1.name} and start of {path2.name} > 0.1 meter"
        )

    merged_path = Path()
    merged_path.columns = path1.columns
    merged_path.anchor = path1.anchor

    sections = []
    if len(path1.sections) > 1:
        sections.extend(path1.sections[:-2])
    sections.append(path1.sections[-1] + path2.sections[0])
    if len(path2.sections) > 1:
        sections.extend(path2.sections[1:])
    merged_path.sections = sections

    merged_path.annotations = path1.annotations
    for annotation in path2.annotations:
        merged_path.append_annotation(
            annotation["type"], annotation["value"], annotation["point_index"] + len(path1.points)
        )

    merged_path.points = path1.points + path2.points

    return merged_path


if __name__ == "__main__":
    args = parse_args()
    output = args.output
    first_traj = args.traj_file_1
    traj_list = args.traj_file_n

    path1 = Path.load(first_traj)
    for i in range(len(traj_list)):
        path2 = Path.load(traj_list[i])
        path1 = merge_two_paths(path1, path2)

    path1.save(output)
    print(f"Trajectory saved in {output}")
